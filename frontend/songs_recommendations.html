<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Recommendations Dashboard - SoundWave</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }

  body {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #0a0a0a 100%);
    color: white;
    min-height: 100vh;
    padding-bottom: 3rem;
  }

  /* Navbar */
  .navbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.2rem 3rem;
    background: rgba(15, 15, 25, 0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(30, 215, 96, 0.3);
    box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
  }

.navbar h2 {
    font-size: 2rem;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
    
    /* ADD THIS BLOCK */
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;
    -webkit-text-fill-color: transparent;
    /* END FIX */
    
    cursor: pointer;
  }

  .back-btn {
    background: rgba(51, 51, 71, 0.8);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 0.8rem 1.5rem;
    border-radius: 12px;
    cursor: pointer;
    text-decoration: none;
    transition: all 0.3s ease;
  }

  .back-btn:hover {
    background: rgba(75, 75, 95, 0.9);
    transform: translateY(-2px);
    border-color: rgba(30, 215, 96, 0.5);
  }

  .container {
    max-width: 1600px;
    margin: 2rem auto;
    padding: 2rem;
  }

  .dashboard-header {
    text-align: center;
    margin-bottom: 3rem;
  }

.dashboard-header h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
    
    /* ADD THIS BLOCK */
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;
    -webkit-text-fill-color: transparent;
    /* END FIX */
  }

  .dashboard-header p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 1.1rem;
  }

  /* Stats Grid */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-bottom: 3rem;
  }

  .stat-card {
    background: rgba(30, 30, 50, 0.8);
    backdrop-filter: blur(20px);
    padding: 1.5rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    transition: all 0.3s ease;
  }

  .stat-card:hover {
    transform: translateY(-5px);
    border-color: rgba(30, 215, 96, 0.5);
  }

  .stat-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.6);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 0.5rem;
  }
.stat-value {
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
    
    /* ADD THIS BLOCK */
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;
    -webkit-text-fill-color: transparent;
    /* END FIX */
  }

  /* Graph Section */
  .graph-section {
    background: rgba(30, 30, 50, 0.8);
    backdrop-filter: blur(20px);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    margin-bottom: 2rem;
    position: relative;
  }

  #graph-container {
    height: 750px;
    width: 100%;
    border-radius: 16px;
    overflow: hidden;
    position: relative;
    margin-bottom: 2rem;
    border: 1px solid rgba(30, 215, 96, 0.3);
    cursor: crosshair;
  }

  /* --- FIXED INFO BOX --- */
  .node-info {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 280px;
    padding: 20px;
    background: rgba(10, 10, 20, 0.95);
    border-radius: 12px;
    border: 1px solid #1ed760;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.8);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateX(20px);
    z-index: 1000;
  }
  
  .node-info.active {
    opacity: 1;
    transform: translateX(0);
    pointer-events: auto;
  }

  .graph-controls {
    display: flex;
    gap: 10px;
    margin-top: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .graph-btn {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.8rem 1.5rem;
    font-size: 0.9rem;
    color: white;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .graph-btn:hover {
    background: rgba(30, 215, 96, 0.2);
    border-color: #1ed760;
    transform: translateY(-2px);
  }

  .legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 15px;
    flex-wrap: wrap;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.1);
  }

  .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; }
  .legend-circle { border-radius: 50%; }

  /* Charts & Song Grid */
  .charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin-bottom: 2rem;
  }

  .chart-container {
    background: rgba(30, 30, 50, 0.8);
    backdrop-filter: blur(20px);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  }

  .chart-title { font-size: 1.3rem; margin-bottom: 1.5rem; color: #1ed760; font-weight: 600; }
  .canvas-wrapper { position: relative; height: 300px; }

  .recommended-songs {
    background: rgba(30, 30, 50, 0.8);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 2rem;
  }

  .songs-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-top: 1rem;
  }

  .song-card {
    background: rgba(20, 20, 40, 0.8);
    border-radius: 12px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .song-card:hover {
    transform: translateY(-5px);
    background: rgba(30, 215, 96, 0.1);
    border-color: rgba(30, 215, 96, 0.5);
  }

  .song-cover {
    width: 100%;
    height: 180px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 0.8rem;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
  }

  .song-title { font-size: 0.95rem; font-weight: 600; margin-bottom: 0.3rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .song-artist { font-size: 0.85rem; color: rgba(255, 255, 255, 0.6); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .song-genre { display: inline-block; margin-top: 0.5rem; padding: 0.3rem 0.6rem; background: linear-gradient(135deg, #8a2be2, #6a0dad); border-radius: 12px; font-size: 0.75rem; }

  .refresh-btn {
    background: linear-gradient(135deg, #1ed760, #1db954);
    color: white;
    border: none;
    padding: 1rem 2rem;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px rgba(30, 215, 96, 0.4);
    display: block;
    margin: 2rem auto;
  }

  .refresh-btn:hover { transform: translateY(-3px) scale(1.05); box-shadow: 0 15px 35px rgba(30, 215, 96, 0.6); }

  .genre-list {
    background: rgba(30, 30, 50, 0.8);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 2rem;
  }

  .genre-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: rgba(20, 20, 40, 0.6);
    border-radius: 8px;
    transition: all 0.3s ease;
  }
  
  .genre-item:hover { background: rgba(30, 215, 96, 0.1); transform: translateX(5px); }
  .genre-name { font-size: 1.1rem; font-weight: 600; }
  .genre-score { font-size: 1rem; color: #1ed760; font-weight: 700; }

  .loading { text-align: center; padding: 3rem; font-size: 1.2rem; color: #1ed760; }
  .spinner { border: 4px solid rgba(255, 255, 255, 0.1); border-top: 4px solid #1ed760; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 2rem auto; }

  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  
  /* Animation classes */
  .pulse-ring {
    animation: pulse-ring 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;
  }
  
  @keyframes pulse-ring {
    0% { transform: scale(0.8); opacity: 0.8; }
    100% { transform: scale(1.5); opacity: 0; }
  }
  
  .glow {
    animation: glow 2s ease-in-out infinite alternate;
  }
  
  @keyframes glow {
    from { filter: drop-shadow(0 0 5px currentColor); }
    to { filter: drop-shadow(0 0 15px currentColor); }
  }
  
  .float {
    animation: float 3s ease-in-out infinite;
  }
  
  @keyframes float {
    0% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
    100% { transform: translateY(0px); }
  }

  /* --- REVISED SORTING VIZ (BOXES) --- */
  .modal {
    display: none; 
    position: fixed; 
    z-index: 2000; 
    left: 0; 
    top: 0; 
    width: 100%; 
    height: 100%; 
    background-color: rgba(0,0,0,0.9); 
    backdrop-filter: blur(8px);
  }

  .modal-content {
    position: absolute; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    background: #0f0f1a;
    background-image: 
        radial-gradient(at 0% 0%, rgba(138, 43, 226, 0.15) 0px, transparent 50%),
        radial-gradient(at 100% 100%, rgba(30, 215, 96, 0.15) 0px, transparent 50%);
    padding: 3rem; 
    border-radius: 24px; 
    border: 1px solid rgba(255, 255, 255, 0.1); 
    width: 95%; 
    max-width: 1100px; 
    text-align: center;
    box-shadow: 0 25px 60px rgba(0,0,0,0.8);
  }

  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
  }

  .close-modal {
    font-size: 2.5rem;
    padding: 0 15px;
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .close-modal:hover {
    color: #ff4757;
    transform: scale(1.2);
  }

  /* --- SPEED SLIDER STYLES --- */
  .speed-control-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin: 0 auto 20px auto;
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 30px;
    width: fit-content;
    border: 1px solid rgba(255,255,255,0.1);
  }

  .speed-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.7);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* Custom Range Slider Styling */
  input[type=range] {
    -webkit-appearance: none;
    appearance: none;
    width: 200px; 
    height: 6px; 
    background: rgba(255,255,255,0.2); 
    border-radius: 5px;
    outline: none; 
    transition: background .2s;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none; 
    appearance: none;
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #1ed760; 
    cursor: pointer; 
    box-shadow: 0 0 10px rgba(30, 215, 96, 0.5);
    transition: transform 0.1s ease;
  }

  input[type=range]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  input[type=range]::-moz-range-thumb {
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #1ed760; 
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(30, 215, 96, 0.5);
  }

  /* Container for the boxes */
  #sort-viz-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 1.5rem;
    min-height: 250px;
    margin: 2rem 0;
    padding: 1rem;
    perspective: 1000px;
  }

  /* Individual Box Design */
  .sort-box {
    width: 100px;
    height: 120px;
    background: rgba(30, 30, 50, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    position: relative;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }

  .sort-box .score-circle {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: linear-gradient(135deg, #2a2a40, #1a1a2e);
    border: 2px solid rgba(255,255,255,0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.1rem;
    font-weight: 700;
    color: white;
    margin-bottom: 10px;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
  }

  .sort-box .label {
    font-size: 0.85rem;
    color: rgba(255,255,255,0.7);
    text-align: center;
    line-height: 1.2;
    max-height: 2.4em;
    overflow: hidden;
  }

  /* --- STATES FOR ANIMATION --- */
  
  /* 1. Comparing (Red/Orange Focus) */
  .sort-box.comparing {
    transform: scale(1.1);
    border-color: #ff4757;
    background: rgba(255, 71, 87, 0.1);
    box-shadow: 0 0 20px rgba(255, 71, 87, 0.3);
    z-index: 10;
  }
  .sort-box.comparing .score-circle {
    border-color: #ff4757;
    color: #ff4757;
  }

  /* 2. Swapping (Blue/Movement) */
  .sort-box.swapping {
    transform: translateY(-15px) scale(1.15) rotate(2deg);
    border-color: #00bcd4;
    background: rgba(0, 188, 212, 0.15);
    box-shadow: 0 15px 30px rgba(0, 188, 212, 0.4);
    z-index: 20;
  }
  .sort-box.swapping .score-circle {
    background: #00bcd4;
    color: #000;
    border-color: white;
  }

  /* 3. Sorted (Green/Locked) */
  .sort-box.sorted {
    border-color: #1ed760;
    background: linear-gradient(180deg, rgba(30, 215, 96, 0.2), rgba(30, 215, 96, 0.05));
    opacity: 1;
    transform: scale(1);
    animation: sortedPulse 0.6s ease-out;
  }
  .sort-box.sorted .score-circle {
    background: linear-gradient(135deg, #1ed760, #15b84f);
    color: #000;
    border-color: #1ed760;
    box-shadow: 0 0 15px rgba(30, 215, 96, 0.7);
    font-weight: 800;
  }
  
  /* Pivot highlighting */
  .sort-box.pivot {
    border-color: #f1c40f;
    background: rgba(241, 196, 15, 0.15);
    box-shadow: 0 0 25px rgba(241, 196, 15, 0.5);
    animation: pivotGlow 1s ease-in-out infinite alternate;
  }
  .sort-box.pivot .score-circle {
    border-color: #f1c40f;
    color: #f1c40f;
    font-weight: 800;
    animation: pivotSpin 2s linear infinite;
  }
  
  @keyframes sortedPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.15); }
    100% { transform: scale(1); }
  }
  
  @keyframes pivotGlow {
    from { box-shadow: 0 0 15px rgba(241, 196, 15, 0.3); }
    to { box-shadow: 0 0 30px rgba(241, 196, 15, 0.7); }
  }
  
  @keyframes pivotSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @media (max-width: 768px) {
    .charts-grid { grid-template-columns: 1fr; }
    .navbar { flex-direction: column; gap: 1rem; }
    .songs-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
  }
</style>
</head>
<body>

<div class="navbar">
  <h2 onclick="window.location.href='song.html'">üéµ Link Lab</h2>
  <a href="song.html" class="back-btn">‚Üê Back to Browse</a>
</div>

<div class="container">
  <div class="dashboard-header">
    <h1>Your Music Universe</h1>
    <p>Visualizing the connections between your Genres, Artists, and Songs</p>
  </div>

  <div id="loadingIndicator" class="loading">
    <div class="spinner"></div>
    Analyzing your music taste...
  </div>

  <div id="dashboardContent" style="display: none;">
    <!-- Stats Grid -->
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Songs</div>
        <div class="stat-value" id="totalSongs">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Unique Genres</div>
        <div class="stat-value" id="uniqueGenres">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Top Genre</div>
        <div class="stat-value" id="topGenre" style="font-size: 1.5rem;">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Unique Artists</div>
        <div class="stat-value" id="uniqueArtists">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Graph Nodes</div>
        <div class="stat-value" id="graphNodes">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Graph Edges</div>
        <div class="stat-value" id="graphEdges">0</div>
      </div>
    </div>

    <!-- Graph Section -->
    <div class="graph-section">
      <h2 class="chart-title">üé∏ Music Relationship Constellation</h2>
      <p style="color: rgba(255,255,255,0.7); margin-bottom: 1rem; text-align: center;">
        <strong>Click on a node</strong> to reveal details. Drag nodes to explore.
      </p>
      
      <div id="graph-container">
        <!-- Info Box (Must sit on top) -->
        <div class="node-info" id="nodeInfo">
            <h3 style="color: #1ed760; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 5px; margin-bottom: 10px;">üéµ Details</h3>
            <div id="infoContent">Click a node to see info</div>
        </div>
      </div>
      
      <div class="graph-controls">
        <button class="graph-btn" id="zoom-fit">‚õ∂ Fit to Screen</button>
        <button class="graph-btn" id="zoom-in">‚ûï Zoom In</button>
        <button class="graph-btn" id="zoom-out">‚ûñ Zoom Out</button>
        <button class="graph-btn" id="toggle-labels">üè∑ Toggle Text</button>
        <button class="graph-btn" id="animate-btn">‚ú® Toggle Animations</button>
        <!-- NEW BUTTON FOR SORTING VISUALIZATION -->
        <button class="graph-btn" id="sort-viz-btn" style="border-color: #8a2be2;">üìä Visualize Sorting</button>
      </div>

      <div class="legend">
        <div class="legend-item"><div class="legend-circle" style="background-color: #1ed760; width: 20px; height: 20px;"></div><span>Genre (Hub)</span></div>
        <div class="legend-item"><div class="legend-circle" style="background-color: #8a2be2; width: 15px; height: 15px;"></div><span>Artist</span></div>
        <div class="legend-item"><div class="legend-circle" style="background-color: #00bcd4; width: 8px; height: 8px;"></div><span>Song</span></div>
      </div>
    </div>

    <!-- Recommended Songs -->
    <div class="recommended-songs">
      <h2 class="chart-title">üéµ Your Recommended Songs</h2>
      <p style="color: rgba(255,255,255,0.7); margin-bottom: 1rem;">
        Based on your listening preferences and iTunes API
      </p>
      <div class="songs-grid" id="recommendedSongsGrid"></div>
    </div>

    <!-- Charts -->
    <div class="charts-grid">
      <div class="chart-container">
        <div class="chart-title">Genre Distribution</div>
        <div class="canvas-wrapper"><canvas id="genreChart"></canvas></div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Top Artists</div>
        <div class="canvas-wrapper"><canvas id="artistChart"></canvas></div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Recommendation Scores</div>
        <div class="canvas-wrapper"><canvas id="scoreChart"></canvas></div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Genre Priority (Distance)</div>
        <div class="canvas-wrapper"><canvas id="priorityChart"></canvas></div>
      </div>
    </div>

    <div class="genre-list">
      <div class="chart-title">Recommended Genres (Dijkstra's Algorithm)</div>
      <div id="genreListContent"></div>
    </div>

    <button class="refresh-btn" onclick="loadRecommendations()">
      üîÑ Refresh Recommendations
    </button>
  </div>
</div>

<!-- SORTING VISUALIZATION MODAL -->
<div id="sortModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 style="font-size: 2rem; background: linear-gradient(to right, #1ed760, #00bcd4); -webkit-background-clip: text; background-clip: text; color: transparent; -webkit-text-fill-color: transparent;">
        Quick Sort Algorithm Visualization
      </h2>
      <button class="close-modal" onclick="closeSortModal()">&times;</button>
    </div>

    <!-- NEW SPEED SLIDER -->
        <!-- NEW SPEED SLIDER -->
    <div class="speed-control-container">
        <span class="speed-label">Fast</span>
        <input type="range" id="speedRange" min="1" max="10" value="5" step="1">
        <span class="speed-label" style="color: #1ed760;">Fast</span>
    </div>
    
    <div id="sort-viz-container">
      <!-- Boxes will be injected here -->
    </div>

    <div id="sort-status" style="font-size: 1.4rem; font-weight: 300; color: white; margin-top: 10px;">
      Ready to sort...
    </div>

    <div style="margin-top: 2rem; display: flex; justify-content: center; gap: 2rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
      <div style="display: flex; align-items: center; gap: 10px;">
        <div style="width: 15px; height: 15px; background: #f1c40f; border-radius: 4px; box-shadow: 0 0 10px #f1c40f;"></div>
        <span style="color: rgba(255,255,255,0.6);">Pivot</span>
      </div>
      <div style="display: flex; align-items: center; gap: 10px;">
        <div style="width: 15px; height: 15px; background: #ff4757; border-radius: 4px; box-shadow: 0 0 10px #ff4757;"></div>
        <span style="color: rgba(255,255,255,0.6);">Comparing</span>
      </div>
      <div style="display: flex; align-items: center; gap: 10px;">
        <div style="width: 15px; height: 15px; background: #00bcd4; border-radius: 4px; box-shadow: 0 0 10px #00bcd4;"></div>
        <span style="color: rgba(255,255,255,0.6);">Swapping</span>
      </div>
    </div>
  </div>
</div>

<script>
const API_BASE = 'http://localhost:5000';
const ITUNES_API = 'https://itunes.apple.com';
let charts = {};
let nodes = [];
let links = [];
let simulation;
let zoom = d3.zoom();
let svg, g;
let showLabels = true;
let animationsEnabled = true;
let selectedNode = null;
let globalData = null; // Store data globally for sorting

// ---------------------------------
// 1. D3 GRAPH LOGIC (FIXED CLICK)
// ---------------------------------
function initGraph() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;

  d3.select("#graph-container svg").remove();

  svg = d3.select("#graph-container")
    .insert("svg", ":first-child")
    .attr("width", width)
    .attr("height", height)
    .style("cursor", "grab")
    .style("background", "radial-gradient(circle at center, #1a1a2e 0%, #000000 100%)")
    .on("click", (e) => {
        // If clicking background, reset everything
        if(e.target.tagName === 'svg') {
            resetGraph();
        }
    });

  g = svg.append("g");
  g.append("g").attr("class", "links");
  g.append("g").attr("class", "nodes");

  zoom = d3.zoom()
    .scaleExtent([0.05, 8])
    .on("zoom", (event) => g.attr("transform", event.transform));

  svg.call(zoom);
}

function buildGenreGraph(data) {
  nodes = [];
  links = [];
  
  const genreCounts = data.genreCounts || {};
  const orderedGenres = data.orderedGenres || [];
  const artistCounts = data.artistCounts || {};
  const graphStructure = data.graphStructure || {};

  // 1. Genre Nodes
  Object.keys(genreCounts).forEach((genre) => {
    nodes.push({
      id: `genre-${genre}`,
      name: genre,
      group: 'genre',
      radius: 20 + Math.min(genreCounts[genre], 25),
      val: genreCounts[genre],
      connectedEdges: 0
    });
  });

  // 2. Artist Nodes
  Object.keys(artistCounts).forEach((artist, idx) => {
    const artistId = `artist-${artist}`;
    nodes.push({
      id: artistId,
      name: artist,
      group: 'artist',
      radius: 12,
      val: artistCounts[artist],
      connectedEdges: 0
    });
    // Link to main genre
    const targetGenre = orderedGenres[idx % orderedGenres.length] || orderedGenres[0];
    links.push({
      source: artistId,
      target: `genre-${targetGenre}`,
      type: 'artist-link',
      weight: 1
    });
  });

  // 3. Song Nodes (Visual)
  Object.keys(genreCounts).forEach((genre) => {
    const count = Math.min(genreCounts[genre], 10);
    for(let i=0; i<count; i++) {
        const songId = `song-${genre}-${i}`;
        nodes.push({
            id: songId,
            name: `Song in ${genre}`,
            group: 'song',
            radius: 5,
            val: 1,
            connectedEdges: 0
        });
        links.push({
            source: songId,
            target: `genre-${genre}`,
            type: 'song-link',
            weight: 0.5
        });
    }
  });

  // 4. Edges from backend
  if (graphStructure.edges) {
    graphStructure.edges.forEach(edge => {
      links.push({
        source: `genre-${edge.from}`,
        target: `genre-${edge.to}`,
        type: 'genre-link',
        weight: edge.weight
      });
    });
  }

  // Calculate connected edges for each node
  nodes.forEach(node => {
    node.connectedEdges = links.filter(link => 
      link.source.id === node.id || link.target.id === node.id
    ).length;
  });

  document.getElementById('graphNodes').textContent = nodes.length;
  document.getElementById('graphEdges').textContent = links.length;

  updateGraph();
}

function updateGraph() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;

  g.selectAll("*").remove();

  // Links with color coding
  const link = g.selectAll(".link")
    .data(links)
    .enter().append("line")
    .attr("class", "link")
    .attr("stroke", d => {
      if(d.type === 'genre-link') return "rgba(30, 215, 96, 0.4)";
      if(d.type === 'artist-link') return "rgba(138, 43, 226, 0.4)";
      return "rgba(255, 255, 255, 0.15)";
    })
    .attr("stroke-width", d => d.type === 'genre-link' ? 2 : 1)
    .style("stroke-dasharray", d => {
      if (animationsEnabled) {
        return d.type === 'genre-link' ? "5,5" : "0";
      }
      return "0";
    })
    .style("animation", animationsEnabled ? "dash-flow 20s linear infinite" : "none");

  // Nodes
  const node = g.selectAll(".node")
    .data(nodes)
    .enter().append("g")
    .attr("class", "node")
    .call(d3.drag()
        .on("start", dragStarted)
        .on("drag", dragged)
        .on("end", dragEnded));

  // Add pulse rings for animation
  if (animationsEnabled) {
    node.append("circle")
      .attr("class", "pulse-ring")
      .attr("r", d => d.radius * 1.5)
      .attr("fill", "none")
      .attr("stroke", d => {
        if(d.group === 'genre') return '#1ed760';
        if(d.group === 'artist') return '#8a2be2';
        return '#00bcd4';
      })
      .attr("stroke-width", 1)
      .attr("stroke-opacity", 0.3)
      .style("pointer-events", "none");
  }

  node.append("circle")
    .attr("class", "node-circle")
    .attr("r", d => d.radius)
    .attr("fill", d => {
        if(d.group === 'genre') return '#1ed760';
        if(d.group === 'artist') return '#8a2be2';
        return '#00bcd4';
    })
    .attr("stroke", "#fff")
    .attr("stroke-width", d => d.group === 'song' ? 0.5 : 2)
    .style("cursor", "pointer")
    .style("transition", animationsEnabled ? "all 0.3s ease" : "none")
    .on("mouseover", function(event, d) {
      if (animationsEnabled) {
        d3.select(this)
          .classed("glow", true)
          .classed("float", d.group === 'genre');
      }
    })
    .on("mouseout", function(event, d) {
      if (animationsEnabled && selectedNode !== d.id) {
        d3.select(this)
          .classed("glow", false)
          .classed("float", false);
      }
    })
    .on("click", (event, d) => {
        event.stopPropagation(); // Stop background click
        handleNodeClick(d);
    });

  // Labels
  const label = node.append("text")
    .text(d => d.group === 'song' ? '' : d.name)
    .attr("x", d => d.radius + 5)
    .attr("y", 4)
    .attr("font-size", d => d.group === 'genre' ? "14px" : "11px")
    .attr("fill", "white")
    .style("pointer-events", "none")
    .style("text-shadow", "0px 0px 3px black")
    .style("display", showLabels ? "block" : "none");

  // Physics
  simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id)
      .distance(d => {
        if(d.type === 'genre-link') return 350; 
        if(d.type === 'artist-link') return 120;
        return 70;
      })
    )
    .force("charge", d3.forceManyBody().strength(d => {
        if(d.group === 'genre') return -900;
        if(d.group === 'artist') return -300;
        return -50;
    }))
    .force("collide", d3.forceCollide().radius(d => d.radius + 15).strength(0.8))
    .force("center", d3.forceCenter(width / 2, height / 2).strength(0.05))
    .on("tick", ticked);
  
  // Add animated background particles if animations enabled
  if (animationsEnabled) {
    addBackgroundParticles();
  }
  
  setTimeout(() => {
    zoomToFit();
  }, 800);

  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node.attr("transform", d => `translate(${d.x},${d.y})`);
  }
}

function handleNodeClick(d) {
  // Remove previous selection
  resetGraph();
  
  // Set selected node
  selectedNode = d.id;
  
  // 1. Reset Styles first
  d3.selectAll(".node-circle")
    .attr("stroke", "#fff")
    .attr("stroke-width", n => n.group === 'song' ? 0.5 : 2)
    .style("filter", "none");

  // 2. Identify connected nodes and links
  const connectedNodeIds = new Set([d.id]);
  const connectedLinks = [];
  
  // Find all connected links
  links.forEach(link => {
    const sourceId = link.source.id || link.source;
    const targetId = link.target.id || link.target;
    
    if (sourceId === d.id || targetId === d.id) {
      connectedLinks.push(link);
      connectedNodeIds.add(sourceId);
      connectedNodeIds.add(targetId);
    }
  });

  // 3. Highlight connected links with purple and blue colors
  g.selectAll(".link")
    .style("stroke", link => {
      if (connectedLinks.includes(link)) {
        // Purple for artist links, blue for song links
        if (link.type === 'artist-link') return '#8a2be2'; // Purple
        if (link.type === 'song-link') return '#00bcd4';   // Blue
        return '#1ed760'; // Green for genre links
      }
      return "rgba(255, 255, 255, 0.05)";
    })
    .style("stroke-width", link => connectedLinks.includes(link) ? 3 : 1)
    .style("stroke-opacity", link => connectedLinks.includes(link) ? 1 : 0.1);

  // 4. Dim unconnected nodes and highlight connected ones
  g.selectAll(".node")
    .select(".node-circle")
    .style("opacity", nodeData => connectedNodeIds.has(nodeData.id) ? 1 : 0.2)
    .attr("stroke-width", nodeData => {
      if (nodeData.id === d.id) return 4;
      if (connectedNodeIds.has(nodeData.id)) return 2;
      return nodeData.group === 'song' ? 0.5 : 2;
    })
    .attr("stroke", nodeData => {
      if (nodeData.id === d.id) return '#ffff00';
      if (connectedNodeIds.has(nodeData.id)) {
        if (nodeData.group === 'artist') return '#8a2be2';
        if (nodeData.group === 'song') return '#00bcd4';
        return '#1ed760';
      }
      return '#fff';
    });

  // Highlight the clicked node with yellow glow
  g.selectAll(".node")
    .filter(nodeData => nodeData.id === d.id)
    .select(".node-circle")
    .attr("stroke", "#ffff00")
    .attr("stroke-width", 4)
    .style("filter", "drop-shadow(0 0 15px #ffff00)");

  // 5. Show Info Box with more detailed information
  const info = document.getElementById('nodeInfo');
  info.classList.add('active');
  
  const typeLabel = d.group.charAt(0).toUpperCase() + d.group.slice(1);
  const edgeCount = connectedLinks.length;
  
  document.getElementById('infoContent').innerHTML = `
    <div style="margin-bottom:10px; padding: 8px; background: rgba(30, 215, 96, 0.1); border-radius: 6px;">
      <strong style="color:#1ed760;">Type:</strong> <span style="color:#aaa">${typeLabel}</span>
    </div>
    <div style="margin-bottom:10px; padding: 8px; background: rgba(138, 43, 226, 0.1); border-radius: 6px;">
      <strong style="color:#8a2be2;">Name:</strong> <span style="font-size:1.1em; color:white">${d.name}</span>
    </div>
    <div style="margin-bottom:10px; padding: 8px; background: rgba(0, 188, 212, 0.1); border-radius: 6px;">
      <strong style="color:#00bcd4;">Connections:</strong> ${edgeCount} links
    </div>
    <div style="margin-bottom:10px; padding: 8px; background: rgba(255, 255, 255, 0.05); border-radius: 6px;">
      <strong>Strength:</strong> ${d.val} plays
    </div>
    <div style="margin-top: 15px; font-size: 0.9em; color: rgba(255, 255, 255, 0.7);">
      Connected to ${connectedNodeIds.size - 1} other nodes
    </div>
  `;
}

function resetGraph() {
  selectedNode = null;
  const info = document.getElementById('nodeInfo');
  info.classList.remove('active');
  
  // Reset all nodes
  g.selectAll(".node-circle")
    .attr("stroke", "#fff")
    .attr("stroke-width", d => d.group === 'song' ? 0.5 : 2)
    .style("opacity", 1)
    .style("filter", "none")
    .classed("glow", false)
    .classed("float", false);
  
  // Reset all links to default colors
  g.selectAll(".link")
    .style("stroke", d => {
      if(d.type === 'genre-link') return "rgba(30, 215, 96, 0.4)";
      if(d.type === 'artist-link') return "rgba(138, 43, 226, 0.4)";
      return "rgba(255, 255, 255, 0.15)";
    })
    .style("stroke-width", d => d.type === 'genre-link' ? 2 : 1)
    .style("stroke-opacity", 1);
  
  // Reset labels
  g.selectAll("text").style("opacity", 1);
}

function addBackgroundParticles() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;
  
  // Create particle layer
  const particleLayer = svg.append("g").attr("class", "particles");
  
  // Add particles
  for (let i = 0; i < 50; i++) {
    particleLayer.append("circle")
      .attr("r", Math.random() * 2 + 0.5)
      .attr("fill", () => {
        const colors = ['rgba(30, 215, 96, 0.3)', 'rgba(138, 43, 226, 0.3)', 'rgba(0, 188, 212, 0.3)'];
        return colors[Math.floor(Math.random() * colors.length)];
      })
      .attr("cx", Math.random() * width)
      .attr("cy", Math.random() * height)
      .style("animation", `float-particle ${Math.random() * 10 + 10}s ease-in-out infinite`)
      .style("animation-delay", `${Math.random() * 5}s`);
  }
  
  // Add CSS for particle animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes float-particle {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px); }
      50% { transform: translate(${Math.random() * 30 - 15}px, ${Math.random() * 30 - 15}px); }
      75% { transform: translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px); }
    }
    @keyframes dash-flow {
      to { stroke-dashoffset: -1000; }
    }
  `;
  document.head.appendChild(style);
}

function zoomToFit() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;
  
  if (nodes.length === 0) return;
  
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodes.forEach(node => {
    if (node.x !== undefined) {
      minX = Math.min(minX, node.x);
      maxX = Math.max(maxX, node.x);
      minY = Math.min(minY, node.y);
      maxY = Math.max(maxY, node.y);
    }
  });
  
  const padding = 80;
  const graphWidth = maxX - minX + 2 * padding;
  const graphHeight = maxY - minY + 2 * padding;
  const scale = Math.min(width / graphWidth, height / graphHeight) * 0.85;
  const translateX = (width - (maxX + minX) * scale) / 2;
  const translateY = (height - (maxY + minY) * scale) / 2;
  
  svg.transition().duration(1000).call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
}

function dragStarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
  svg.style("cursor", "grabbing");
}

function dragged(event, d) {
  d.fx = event.x;
  d.fy = event.y;
}

function dragEnded(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
  svg.style("cursor", "grab");
}

// Add toggle animations button
document.getElementById('animate-btn').addEventListener('click', () => {
  animationsEnabled = !animationsEnabled;
  updateGraph();
});

document.getElementById('zoom-in').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 1.3));
document.getElementById('zoom-out').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 0.7));
document.getElementById('zoom-fit').addEventListener('click', zoomToFit);
document.getElementById('toggle-labels').addEventListener('click', () => {
  showLabels = !showLabels;
  g.selectAll("text").style("display", showLabels ? "block" : "none");
});

window.addEventListener('resize', () => {
  if (svg) {
    const container = document.getElementById('graph-container');
    svg.attr("width", container.clientWidth).attr("height", container.clientHeight);
    setTimeout(zoomToFit, 100);
  }
});

// ---------------------------------
// 2. SONG RECOMMENDATION LOGIC
// ---------------------------------
async function loadRecommendedSongs(orderedGenres) {
  if (!orderedGenres || orderedGenres.length === 0) return;

  const topGenres = orderedGenres.slice(0, 3);
  let songs = [];

  for (const genre of topGenres) {
    try {
      const response = await fetch(`${ITUNES_API}/search?term=${encodeURIComponent(genre)}&media=music&entity=song&limit=15`);
      const data = await response.json();
      
      if (data.results) {
        songs = songs.concat(data.results.map(track => ({
          id: track.trackId,
          title: track.trackName,
          artist: track.artistName,
          cover: track.artworkUrl100.replace('100x100', '300x300'),
          genre: genre,
          preview: track.previewUrl
        })));
      }
    } catch (error) {
      console.error(`Error fetching songs for ${genre}:`, error);
    }
  }

  songs = songs.sort(() => Math.random() - 0.5).slice(0, 12);
  displayRecommendedSongs(songs);
}

function displayRecommendedSongs(songs) {
  const grid = document.getElementById('recommendedSongsGrid');
  grid.innerHTML = '';

  songs.forEach(song => {
    const card = document.createElement('div');
    card.className = 'song-card';
    card.innerHTML = `
      <img class="song-cover" src="${song.cover}" alt="${song.title}" 
           onerror="this.src='https://via.placeholder.com/300x300/1a1a2e/1ed760?text=‚ô™'">
      <div class="song-title">${song.title}</div>
      <div class="song-artist">${song.artist}</div>
      <div class="song-genre">${song.genre}</div>
    `;
    card.addEventListener('click', () => {
      if (song.preview) {
        const audio = new Audio(song.preview);
        audio.play().catch(e => console.log('Autoplay blocked'));
        alert(`‚ñ∂ Playing preview: ${song.title}`);
      } else {
        alert(`No preview available for ${song.title}`);
      }
    });
    grid.appendChild(card);
  });
}

// ---------------------------------
// 3. MAIN DATA LOADING
// ---------------------------------
async function loadRecommendations() {
  const loadingIndicator = document.getElementById('loadingIndicator');
  const dashboardContent = document.getElementById('dashboardContent');
  
  loadingIndicator.style.display = 'block';
  dashboardContent.style.display = 'none';

  try {
    const playlist = JSON.parse(localStorage.getItem('playlist') || '[]');
    const recommendations = JSON.parse(localStorage.getItem('recommendations') || '[]');
    const users = JSON.parse(localStorage.getItem('users') || '[]');

    const response = await fetch(`${API_BASE}/api/recommend`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ playlist, recommendations, users })
    });

    if (!response.ok) throw new Error('Backend error');

    const data = await response.json();
    globalData = data; // SAVE DATA FOR SORTING
    
    loadingIndicator.style.display = 'none';
    dashboardContent.style.display = 'block';

    if (data.success) {
      setTimeout(() => {
        displayDashboard(data);
        initGraph();
        buildGenreGraph(data);
        loadRecommendedSongs(data.orderedGenres);
      }, 50);
    }

  } catch (error) {
    console.error('Error loading recommendations:', error);
    loadingIndicator.innerHTML = `
      <div style="color: #ff4757;">
        ‚ö† Backend connection failed.<br>
        <button class="refresh-btn" onclick="loadRecommendations()">Try Again</button>
      </div>
    `;
  }
}

function displayDashboard(data) {
  const playlist = JSON.parse(localStorage.getItem('playlist') || '[]');
  document.getElementById('totalSongs').textContent = playlist.length;
  document.getElementById('uniqueGenres').textContent = Object.keys(data.genreCounts || {}).length;
  document.getElementById('topGenre').textContent = data.orderedGenres[0] || '-';
  document.getElementById('uniqueArtists').textContent = Object.keys(data.artistCounts || {}).length;

  createChart('genreChart', 'doughnut', data.genreCounts);
  createChart('artistChart', 'bar', data.artistCounts);
  createChart('scoreChart', 'radar', data.recommendationScores);
  createChart('priorityChart', 'line', data.distances || {});
  
  displayGenreList(data.orderedGenres, data.recommendationScores);
}

function createChart(id, type, dataObj) {
    const ctx = document.getElementById(id);
    if(charts[id]) charts[id].destroy();
    
    let labels = Object.keys(dataObj);
    let values = Object.values(dataObj);
    
    if(labels.length > 10) {
        labels = labels.slice(0, 10);
        values = values.slice(0, 10);
    }

    const config = {
        type: type,
        data: {
            labels: labels,
            datasets: [{
                label: 'Data',
                data: values,
                backgroundColor: ['#1ed760', '#8a2be2', '#00bcd4', '#ff4757', '#ffa502'],
                borderColor: '#fff',
                borderWidth: 1,
                fill: type === 'line'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: type === 'doughnut' } },
            scales: (type === 'bar' || type === 'line') ? {
                y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                x: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }
            } : (type === 'radar' ? {
                r: { ticks: { display: false }, grid: { color: 'rgba(255,255,255,0.1)' }, pointLabels: { color: '#fff' } }
            } : {})
        }
    };
    charts[id] = new Chart(ctx, config);
}

function displayGenreList(orderedGenres, scores) {
  const container = document.getElementById('genreListContent');
  container.innerHTML = '';
  orderedGenres.slice(0, 10).forEach((genre, index) => {
    const item = document.createElement('div');
    item.className = 'genre-item';
    item.innerHTML = `
      <div><span style="color: #1ed760; font-weight: bold; margin-right: 0.5rem;">#${index + 1}</span>
      <span class="genre-name">${genre}</span></div>
      <div class="genre-score">Score: ${scores[genre] || 0}</div>
    `;
    container.appendChild(item);
  });
}

// ---------------------------------
// 4. SORTING VISUALIZATION LOGIC (QUICK SORT + SPEED CONTROL)
// ---------------------------------

let isSorting = false;
let speedFactor = 1.0; // Multiplier for animation speed

// Listen for slider changes
document.getElementById('speedRange').addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    // Map slider 1-10: 1 = Slow (0.25x), 4 = Normal (1x), 10 = Fast (2.5x)
    if(val < 4) {
        speedFactor = 0.25 * val; 
    } else {
        speedFactor = 1 + ((val - 4) * 0.25); 
    }
});

document.getElementById('sort-viz-btn').addEventListener('click', () => {
    // If no data is loaded yet, use mock data to demonstrate the visual
    if(!globalData || !globalData.recommendationScores) {
        globalData = {
           recommendationScores: { "Pop": 95, "Rock": 82, "Jazz": 60, "Hip Hop": 88, "Classical": 45, "Indie": 75, "Metal": 55, "Blues": 65 }
        };
            }
    openSortModal();
});

function openSortModal() {
    const modal = document.getElementById('sortModal');
    modal.style.display = 'block';
    
    // Reset speed to default
    speedFactor = 1.0;
    document.getElementById('speedRange').value = 4;
    
    // Prepare data for sorting visualization
    const scores = globalData.recommendationScores;
    const items = Object.entries(scores).map(([genre, score], index) => ({
        id: index,
        genre: genre,
        score: score,
        color: getColorForScore(score)
    }));
    
    renderSortingBoxes(items);
    
    // Start the sorting visualization
    visualizeQuickSort([...items], document.getElementById('sort-viz-container'));
}

function closeSortModal() {
    document.getElementById('sortModal').style.display = 'none';
    isSorting = false;
}

function getColorForScore(score) {
    if (score >= 90) return '#1ed760';
    if (score >= 75) return '#8a2be2';
    if (score >= 60) return '#00bcd4';
    if (score >= 45) return '#ffa502';
    return '#ff4757';
}

function renderSortingBoxes(items) {
    const container = document.getElementById('sort-viz-container');
    container.innerHTML = '';
    
    items.forEach(item => {
        const box = document.createElement('div');
        box.className = 'sort-box';
        box.id = `box-${item.id}`;
        box.innerHTML = `
            <div class="score-circle" style="background: ${item.color}">
                ${item.score}
            </div>
            <div class="label">${item.genre}</div>
        `;
        container.appendChild(box);
    });
}

async function visualizeQuickSort(items, container) {
    if (isSorting) return;
    isSorting = true;
    
    const status = document.getElementById('sort-status');
    status.textContent = "Starting Quick Sort...";
    
    // Helper function for delays with speed control
    const delay = (ms) => {
        // Apply speed factor - lower factor = faster, higher factor = slower
        // We invert the logic: speedFactor > 1 = slower, < 1 = faster
        const adjustedMs = ms / speedFactor;
        return new Promise(resolve => setTimeout(resolve, adjustedMs));
    };
    
    // Clear any existing classes
    const clearAllStates = () => {
        container.querySelectorAll('.sort-box').forEach(box => {
            box.classList.remove('comparing', 'swapping', 'sorted', 'pivot');
        });
    };
    
    // Update status with delay
    const updateStatus = async (text) => {
        status.textContent = text;
        await delay(500);
    };
    
    // Highlight boxes being compared
    const highlightComparing = async (idx1, idx2) => {
        clearAllStates();
        document.getElementById(`box-${items[idx1].id}`).classList.add('comparing');
        document.getElementById(`box-${items[idx2].id}`).classList.add('comparing');
        await delay(800);
    };
    
    // Highlight pivot
    const highlightPivot = async (idx) => {
        document.getElementById(`box-${items[idx].id}`).classList.add('pivot');
        await delay(600);
    };
    
    // Show swapping animation
    const animateSwap = async (idx1, idx2) => {
        const box1 = document.getElementById(`box-${items[idx1].id}`);
        const box2 = document.getElementById(`box-${items[idx2].id}`);
        
        box1.classList.add('swapping');
        box2.classList.add('swapping');
        
        await delay(600);
        
        // Swap positions in DOM
        const parent = box1.parentNode;
        const temp = document.createElement('div');
        parent.insertBefore(temp, box1);
        parent.insertBefore(box1, box2);
        parent.insertBefore(box2, temp);
        parent.removeChild(temp);
        
        // Swap in array
        [items[idx1], items[idx2]] = [items[idx2], items[idx1]];
        
        await delay(400);
        
        box1.classList.remove('swapping');
        box2.classList.remove('swapping');
    };
    
    // Mark as sorted
    const markSorted = async (idx) => {
        const box = document.getElementById(`box-${items[idx].id}`);
        box.classList.add('sorted');
        await delay(300);
    };
    
    // Quick Sort implementation with visualization
    async function quickSort(arr, low, high) {
        if (low < high) {
            await updateStatus(`Partitioning from position ${low} to ${high}`);
            
            const pi = await partition(arr, low, high);
            
            await updateStatus(`Pivot ${arr[pi].genre} (score: ${arr[pi].score}) is now in correct position`);
            await markSorted(pi);
            
            await updateStatus(`Sorting left side (${low} to ${pi-1})`);
            await quickSort(arr, low, pi - 1);
            
            await updateStatus(`Sorting right side (${pi+1} to ${high})`);
            await quickSort(arr, pi + 1, high);
        } else if (low === high) {
            await markSorted(low);
        }
    }
    
    async function partition(arr, low, high) {
        // Choose pivot (last element)
        const pivot = arr[high];
        await highlightPivot(high);
        
        let i = low - 1;
        
        for (let j = low; j < high; j++) {
            await updateStatus(`Comparing ${arr[j].genre} (${arr[j].score}) with pivot ${pivot.genre} (${pivot.score})`);
            await highlightComparing(j, high);
            
            if (arr[j].score > pivot.score) { // Sort descending (highest scores first)
                i++;
                
                if (i !== j) {
                    await updateStatus(`Swapping ${arr[i].genre} with ${arr[j].genre}`);
                    await animateSwap(i, j);
                }
            }
        }
        
        // Place pivot in correct position
        await updateStatus(`Placing pivot ${pivot.genre} in correct position`);
        await animateSwap(i + 1, high);
        
        return i + 1;
    }
    
    // Start sorting
    try {
        await quickSort(items, 0, items.length - 1);
        
        // Mark all as sorted
        for (let i = 0; i < items.length; i++) {
            await markSorted(i);
        }
        
        await updateStatus("‚úÖ Sorting Complete! Items sorted by recommendation score (highest to lowest)");
        
        // Show final sorted order
        let finalOrder = "Final order: ";
        items.forEach((item, idx) => {
            finalOrder += `${idx+1}. ${item.genre}(${item.score}) `;
        });
        console.log(finalOrder);
        
    } catch (error) {
        console.error("Sorting visualization error:", error);
        status.textContent = "Sorting interrupted";
    } finally {
        isSorting = false;
    }
}

// Close modal when clicking outside
window.addEventListener('click', (event) => {
    const modal = document.getElementById('sortModal');
    if (event.target === modal) {
        closeSortModal();
    }
});

// ---------------------------------
// 5. INITIALIZE ON LOAD
// ---------------------------------
document.addEventListener('DOMContentLoaded', () => {
    loadRecommendations();
    
    // Initialize speed control - ONLY ONCE
    // Initialize speed control - ONLY ONCE
    const speedRange = document.getElementById('speedRange');
    if (speedRange) {
        speedRange.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            
            // INVERTED mapping for intuitive slider (left = slow, right = fast)
            const speedMap = {
                1: 6.0,   // 6x slower (very slow)
                2: 4.0,   // 4x slower
                3: 2.5,   // 2.5x slower
                4: 1.5,   // 1.5x slower
                5: 1.0,   // Normal
                6: 0.6,   // 1.7x faster
                7: 0.3,   // 3.3x faster
                8: 0.2,   // 5x faster
                9: 0.15,  // 6.7x faster
                10: 0.1   // 10x faster
            };
            
            speedFactor = speedMap[val] || 1.0;
            
            // Update visual indicator
            const speedIndicator = document.querySelector('.speed-label[style*="color: #1ed760"]');
            if (speedIndicator) {
                let speedText;
                if (val <= 2) speedText = 'Very Slow';
                else if (val <= 4) speedText = 'Slow';
                else if (val === 5) speedText = 'Normal';
                else if (val <= 7) speedText = 'Fast';
                else if (val <= 9) speedText = 'Very Fast';
                else speedText = 'Ultra Fast';
                
                speedIndicator.textContent = speedText;
                
                // Update the color based on speed
                if (val <= 4) {
                    speedIndicator.style.color = '#ff4757'; // Red for slow
                } else if (val === 5) {
                    speedIndicator.style.color = '#1ed760'; // Lime green for normal
                } else {
                    speedIndicator.style.color = '#00ff00'; // Green for fast
                }
            }
            
            console.log(`Speed: slider=${val}, factor=${speedFactor.toFixed(2)}x, ${speedFactor < 1 ? 'FASTER' : 'SLOWER'} than normal`);
        });
        
        // Trigger initial update
        speedRange.dispatchEvent(new Event('input'));
    }
});
</script>
</body>
</html>