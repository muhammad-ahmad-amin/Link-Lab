<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Recommendations Dashboard - SoundWave</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }

  body {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #0a0a0a 100%);
    color: white;
    min-height: 100vh;
    padding-bottom: 3rem;
  }

  /* Navbar */
  .navbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.2rem 3rem;
    background: rgba(15, 15, 25, 0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(30, 215, 96, 0.3);
    box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
  }

  .navbar h2 {
    font-size: 2rem;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    cursor: pointer;
  }

  .back-btn {
    background: rgba(51, 51, 71, 0.8);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 0.8rem 1.5rem;
    border-radius: 12px;
    cursor: pointer;
    text-decoration: none;
    transition: all 0.3s ease;
  }

  .back-btn:hover {
    background: rgba(75, 75, 95, 0.9);
    transform: translateY(-2px);
    border-color: rgba(30, 215, 96, 0.5);
  }

  .container {
    max-width: 1600px;
    margin: 2rem auto;
    padding: 2rem;
  }

  .dashboard-header {
    text-align: center;
    margin-bottom: 3rem;
  }

  .dashboard-header h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .dashboard-header p {
    color: rgba(255, 255, 255, 0.7);
    font-size: 1.1rem;
  }

  /* Stats Grid */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-bottom: 3rem;
  }

  .stat-card {
    background: rgba(30, 30, 50, 0.8);
    backdrop-filter: blur(20px);
    padding: 1.5rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    transition: all 0.3s ease;
  }

  .stat-card:hover {
    transform: translateY(-5px);
    border-color: rgba(30, 215, 96, 0.5);
  }

  .stat-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.6);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 0.5rem;
  }

  .stat-value {
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  /* Graph Section */
  .graph-section {
    background: rgba(30, 30, 50, 0.8);
    backdrop-filter: blur(20px);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    margin-bottom: 2rem;
    position: relative;
  }

  #graph-container {
    height: 750px;
    width: 100%;
    border-radius: 16px;
    overflow: hidden;
    position: relative;
    margin-bottom: 2rem;
    border: 1px solid rgba(30, 215, 96, 0.3);
    cursor: crosshair;
  }

  /* --- FIXED INFO BOX --- */
  .node-info {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 280px;
    padding: 20px;
    background: rgba(10, 10, 20, 0.95);
    border-radius: 12px;
    border: 1px solid #1ed760;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.8);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateX(20px);
    z-index: 1000;
  }
  
  .node-info.active {
    opacity: 1;
    transform: translateX(0);
    pointer-events: auto;
  }

  .graph-controls {
    display: flex;
    gap: 10px;
    margin-top: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .graph-btn {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.8rem 1.5rem;
    font-size: 0.9rem;
    color: white;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .graph-btn:hover {
    background: rgba(30, 215, 96, 0.2);
    border-color: #1ed760;
    transform: translateY(-2px);
  }

  .legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 15px;
    flex-wrap: wrap;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.1);
  }

  .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.9rem; }
  .legend-circle { border-radius: 50%; }

  /* Charts & Song Grid */
  .charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
    margin-bottom: 2rem;
  }

  .chart-container {
    background: rgba(30, 30, 50, 0.8);
    backdrop-filter: blur(20px);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  }

  .chart-title { font-size: 1.3rem; margin-bottom: 1.5rem; color: #1ed760; font-weight: 600; }
  .canvas-wrapper { position: relative; height: 300px; }

  .recommended-songs {
    background: rgba(30, 30, 50, 0.8);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 2rem;
  }

  .songs-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1.5rem;
    margin-top: 1rem;
  }

  .song-card {
    background: rgba(20, 20, 40, 0.8);
    border-radius: 12px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .song-card:hover {
    transform: translateY(-5px);
    background: rgba(30, 215, 96, 0.1);
    border-color: rgba(30, 215, 96, 0.5);
  }

  .song-cover {
    width: 100%;
    height: 180px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 0.8rem;
    background: linear-gradient(135deg, #1ed760, #8a2be2);
  }

  .song-title { font-size: 0.95rem; font-weight: 600; margin-bottom: 0.3rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .song-artist { font-size: 0.85rem; color: rgba(255, 255, 255, 0.6); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .song-genre { display: inline-block; margin-top: 0.5rem; padding: 0.3rem 0.6rem; background: linear-gradient(135deg, #8a2be2, #6a0dad); border-radius: 12px; font-size: 0.75rem; }

  .refresh-btn {
    background: linear-gradient(135deg, #1ed760, #1db954);
    color: white;
    border: none;
    padding: 1rem 2rem;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px rgba(30, 215, 96, 0.4);
    display: block;
    margin: 2rem auto;
  }

  .refresh-btn:hover { transform: translateY(-3px) scale(1.05); box-shadow: 0 15px 35px rgba(30, 215, 96, 0.6); }

  .genre-list {
    background: rgba(30, 30, 50, 0.8);
    padding: 2rem;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 2rem;
  }

  .genre-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: rgba(20, 20, 40, 0.6);
    border-radius: 8px;
    transition: all 0.3s ease;
  }
  
  .genre-item:hover { background: rgba(30, 215, 96, 0.1); transform: translateX(5px); }
  .genre-name { font-size: 1.1rem; font-weight: 600; }
  .genre-score { font-size: 1rem; color: #1ed760; font-weight: 700; }

  .loading { text-align: center; padding: 3rem; font-size: 1.2rem; color: #1ed760; }
  .spinner { border: 4px solid rgba(255, 255, 255, 0.1); border-top: 4px solid #1ed760; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 2rem auto; }

  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  
  /* Animation classes */
  .pulse-ring {
    animation: pulse-ring 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;
  }
  
  @keyframes pulse-ring {
    0% { transform: scale(0.8); opacity: 0.8; }
    100% { transform: scale(1.5); opacity: 0; }
  }
  
  .glow {
    animation: glow 2s ease-in-out infinite alternate;
  }
  
  @keyframes glow {
    from { filter: drop-shadow(0 0 5px currentColor); }
    to { filter: drop-shadow(0 0 15px currentColor); }
  }
  
  .float {
    animation: float 3s ease-in-out infinite;
  }
  
  @keyframes float {
    0% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
    100% { transform: translateY(0px); }
  }

  /* --- REVISED SORTING VIZ (BOXES) --- */
  .modal {
    display: none; 
    position: fixed; 
    z-index: 2000; 
    left: 0; 
    top: 0; 
    width: 100%; 
    height: 100%; 
    background-color: rgba(0,0,0,0.9); 
    backdrop-filter: blur(8px);
  }

  .modal-content {
    position: absolute; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    background: #0f0f1a;
    background-image: 
        radial-gradient(at 0% 0%, rgba(138, 43, 226, 0.15) 0px, transparent 50%),
        radial-gradient(at 100% 100%, rgba(30, 215, 96, 0.15) 0px, transparent 50%);
    padding: 3rem; 
    border-radius: 24px; 
    border: 1px solid rgba(255, 255, 255, 0.1); 
    width: 95%; 
    max-width: 1100px; 
    text-align: center;
    box-shadow: 0 25px 60px rgba(0,0,0,0.8);
  }

  /* --- SPEED SLIDER STYLES --- */
  .speed-control-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin: 0 auto 20px auto;
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 30px;
    width: fit-content;
    border: 1px solid rgba(255,255,255,0.1);
  }

  .speed-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.7);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* Custom Range Slider Styling */
  input[type=range] {
    -webkit-appearance: none; /* Override default CSS styles */
    appearance: none;
    width: 200px; 
    height: 6px; 
    background: rgba(255,255,255,0.2); 
    border-radius: 5px;
    outline: none; 
    transition: background .2s;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none; 
    appearance: none;
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #1ed760; 
    cursor: pointer; 
    box-shadow: 0 0 10px rgba(30, 215, 96, 0.5);
    transition: transform 0.1s ease;
  }

  input[type=range]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  input[type=range]::-moz-range-thumb {
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #1ed760; 
    cursor: pointer;
    border: none;
    box-shadow: 0 0 10px rgba(30, 215, 96, 0.5);
  }

  /* Container for the boxes */
  #sort-viz-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 1.5rem;
    min-height: 250px;
    margin: 2rem 0;
    padding: 1rem;
    perspective: 1000px;
  }

  /* Individual Box Design */
  .sort-box {
    width: 100px;
    height: 120px;
    background: rgba(30, 30, 50, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 10px;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    position: relative;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }

  .sort-box .score-circle {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: linear-gradient(135deg, #2a2a40, #1a1a2e);
    border: 2px solid rgba(255,255,255,0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.1rem;
    font-weight: 700;
    color: white;
    margin-bottom: 10px;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
  }

  .sort-box .label {
    font-size: 0.85rem;
    color: rgba(255,255,255,0.7);
    text-align: center;
    line-height: 1.2;
    max-height: 2.4em;
    overflow: hidden;
  }

  /* --- STATES FOR ANIMATION --- */
  
  /* 1. Comparing (Red/Orange Focus) */
  .sort-box.comparing {
    transform: scale(1.1);
    border-color: #ff4757;
    background: rgba(255, 71, 87, 0.1);
    box-shadow: 0 0 20px rgba(255, 71, 87, 0.3);
    z-index: 10;
  }
  .sort-box.comparing .score-circle {
    border-color: #ff4757;
    color: #ff4757;
  }

  /* 2. Swapping (Blue/Movement) */
  .sort-box.swapping {
    transform: translateY(-15px) scale(1.15) rotate(2deg);
    border-color: #00bcd4;
    background: rgba(0, 188, 212, 0.15);
    box-shadow: 0 15px 30px rgba(0, 188, 212, 0.4);
    z-index: 20;
  }
  .sort-box.swapping .score-circle {
    background: #00bcd4;
    color: #000;
    border-color: white;
  }

  /* 3. Sorted (Green/Locked) */
  .sort-box.sorted {
    border-color: #1ed760;
    background: linear-gradient(180deg, rgba(30, 215, 96, 0.1), transparent);
    opacity: 0.8;
    transform: scale(1);
  }
  .sort-box.sorted .score-circle {
    background: #1ed760;
    color: #000;
    border-color: #1ed760;
    box-shadow: 0 0 10px rgba(30, 215, 96, 0.5);
  }

  @media (max-width: 768px) {
    .charts-grid { grid-template-columns: 1fr; }
    .navbar { flex-direction: column; gap: 1rem; }
    .songs-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
  }
</style>
</head>
<body>

<div class="navbar">
  <h2 onclick="window.location.href='song.html'">üéµ Link Lab</h2>
  <a href="song.html" class="back-btn">‚Üê Back to Browse</a>
</div>

<div class="container">
  <div class="dashboard-header">
    <h1>Your Music Universe</h1>
    <p>Visualizing the connections between your Genres, Artists, and Songs</p>
  </div>

  <div id="loadingIndicator" class="loading">
    <div class="spinner"></div>
    Analyzing your music taste...
  </div>

  <div id="dashboardContent" style="display: none;">
    <!-- Stats Grid -->
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Songs</div>
        <div class="stat-value" id="totalSongs">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Unique Genres</div>
        <div class="stat-value" id="uniqueGenres">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Top Genre</div>
        <div class="stat-value" id="topGenre" style="font-size: 1.5rem;">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Unique Artists</div>
        <div class="stat-value" id="uniqueArtists">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Graph Nodes</div>
        <div class="stat-value" id="graphNodes">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Graph Edges</div>
        <div class="stat-value" id="graphEdges">0</div>
      </div>
    </div>

    <!-- Graph Section -->
    <div class="graph-section">
      <h2 class="chart-title">üé∏ Music Relationship Constellation</h2>
      <p style="color: rgba(255,255,255,0.7); margin-bottom: 1rem; text-align: center;">
        <strong>Click on a node</strong> to reveal details. Drag nodes to explore.
      </p>
      
      <div id="graph-container">
        <!-- Info Box (Must sit on top) -->
        <div class="node-info" id="nodeInfo">
            <h3 style="color: #1ed760; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 5px; margin-bottom: 10px;">üéµ Details</h3>
            <div id="infoContent">Click a node to see info</div>
        </div>
      </div>
      
      <div class="graph-controls">
        <button class="graph-btn" id="zoom-fit">‚õ∂ Fit to Screen</button>
        <button class="graph-btn" id="zoom-in">‚ûï Zoom In</button>
        <button class="graph-btn" id="zoom-out">‚ûñ Zoom Out</button>
        <button class="graph-btn" id="toggle-labels">üè∑ Toggle Text</button>
        <button class="graph-btn" id="animate-btn">‚ú® Toggle Animations</button>
        <!-- NEW BUTTON FOR SORTING VISUALIZATION -->
        <button class="graph-btn" id="sort-viz-btn" style="border-color: #8a2be2;">üìä Visualize Sorting</button>
      </div>

      <div class="legend">
        <div class="legend-item"><div class="legend-circle" style="background-color: #1ed760; width: 20px; height: 20px;"></div><span>Genre (Hub)</span></div>
        <div class="legend-item"><div class="legend-circle" style="background-color: #8a2be2; width: 15px; height: 15px;"></div><span>Artist</span></div>
        <div class="legend-item"><div class="legend-circle" style="background-color: #00bcd4; width: 8px; height: 8px;"></div><span>Song</span></div>
      </div>
    </div>

    <!-- Recommended Songs -->
    <div class="recommended-songs">
      <h2 class="chart-title">üéµ Your Recommended Songs</h2>
      <p style="color: rgba(255,255,255,0.7); margin-bottom: 1rem;">
        Based on your listening preferences and iTunes API
      </p>
      <div class="songs-grid" id="recommendedSongsGrid"></div>
    </div>

    <!-- Charts -->
    <div class="charts-grid">
      <div class="chart-container">
        <div class="chart-title">Genre Distribution</div>
        <div class="canvas-wrapper"><canvas id="genreChart"></canvas></div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Top Artists</div>
        <div class="canvas-wrapper"><canvas id="artistChart"></canvas></div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Recommendation Scores</div>
        <div class="canvas-wrapper"><canvas id="scoreChart"></canvas></div>
      </div>

      <div class="chart-container">
        <div class="chart-title">Genre Priority (Distance)</div>
        <div class="canvas-wrapper"><canvas id="priorityChart"></canvas></div>
      </div>
    </div>

    <div class="genre-list">
      <div class="chart-title">Recommended Genres (Dijkstra's Algorithm)</div>
      <div id="genreListContent"></div>
    </div>

    <button class="refresh-btn" onclick="loadRecommendations()">
      üîÑ Refresh Recommendations
    </button>
  </div>
</div>

<!-- SORTING VISUALIZATION MODAL -->
<!-- SORTING VISUALIZATION MODAL -->
<div id="sortModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 style="font-size: 2rem; background: linear-gradient(to right, #1ed760, #00bcd4); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
        Sorting Algorithms
      </h2>
      <button class="close-modal" onclick="closeSortModal()" style="font-size: 2.5rem; padding: 0 15px; background:none; border:none; color:white; cursor:pointer;">&times;</button>
    </div>

    <!-- NEW SPEED SLIDER -->
    <div class="speed-control-container">
        <span class="speed-label">Slow</span>
        <input type="range" id="speedRange" min="1" max="10" value="4" step="1">
        <span class="speed-label" style="color: #1ed760;">Fast</span>
    </div>
    
    <div id="sort-viz-container">
      <!-- Boxes will be injected here -->
    </div>

    <div id="sort-status" style="font-size: 1.4rem; font-weight: 300; color: white; margin-top: 10px;">
      Ready to sort...
    </div>

    <div style="margin-top: 2rem; display: flex; justify-content: center; gap: 2rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
      <div style="display: flex; align-items: center; gap: 10px;">
        <div style="width: 15px; height: 15px; background: #f1c40f; border-radius: 4px; box-shadow: 0 0 10px #f1c40f;"></div>
        <span style="color: rgba(255,255,255,0.6);">Pivot</span>
      </div>
      <div style="display: flex; align-items: center; gap: 10px;">
        <div style="width: 15px; height: 15px; background: #ff4757; border-radius: 4px; box-shadow: 0 0 10px #ff4757;"></div>
        <span style="color: rgba(255,255,255,0.6);">Comparing</span>
      </div>
      <div style="display: flex; align-items: center; gap: 10px;">
        <div style="width: 15px; height: 15px; background: #00bcd4; border-radius: 4px; box-shadow: 0 0 10px #00bcd4;"></div>
        <span style="color: rgba(255,255,255,0.6);">Swapping</span>
      </div>
    </div>
  </div>
</div>

<script>
const API_BASE = 'http://localhost:5000';
const ITUNES_API = 'https://itunes.apple.com';
let charts = {};
let nodes = [];
let links = [];
let simulation;
let zoom = d3.zoom();
let svg, g;
let showLabels = true;
let animationsEnabled = true;
let selectedNode = null;
let globalData = null; // Store data globally for sorting

// ---------------------------------
// 1. D3 GRAPH LOGIC (FIXED CLICK)
// ---------------------------------
function initGraph() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;

  d3.select("#graph-container svg").remove();

  svg = d3.select("#graph-container")
    .insert("svg", ":first-child")
    .attr("width", width)
    .attr("height", height)
    .style("cursor", "grab")
    .style("background", "radial-gradient(circle at center, #1a1a2e 0%, #000000 100%)")
    .on("click", (e) => {
        // If clicking background, reset everything
        if(e.target.tagName === 'svg') {
            resetGraph();
        }
    });

  g = svg.append("g");
  g.append("g").attr("class", "links");
  g.append("g").attr("class", "nodes");

  zoom = d3.zoom()
    .scaleExtent([0.05, 8])
    .on("zoom", (event) => g.attr("transform", event.transform));

  svg.call(zoom);
}

function buildGenreGraph(data) {
  nodes = [];
  links = [];
  
  const genreCounts = data.genreCounts || {};
  const orderedGenres = data.orderedGenres || [];
  const artistCounts = data.artistCounts || {};
  const graphStructure = data.graphStructure || {};

  // 1. Genre Nodes
  Object.keys(genreCounts).forEach((genre) => {
    nodes.push({
      id: `genre-${genre}`,
      name: genre,
      group: 'genre',
      radius: 20 + Math.min(genreCounts[genre], 25),
      val: genreCounts[genre],
      connectedEdges: 0
    });
  });

  // 2. Artist Nodes
  Object.keys(artistCounts).forEach((artist, idx) => {
    const artistId = `artist-${artist}`;
    nodes.push({
      id: artistId,
      name: artist,
      group: 'artist',
      radius: 12,
      val: artistCounts[artist],
      connectedEdges: 0
    });
    // Link to main genre
    const targetGenre = orderedGenres[idx % orderedGenres.length] || orderedGenres[0];
    links.push({
      source: artistId,
      target: `genre-${targetGenre}`,
      type: 'artist-link',
      weight: 1
    });
  });

  // 3. Song Nodes (Visual)
  Object.keys(genreCounts).forEach((genre) => {
    const count = Math.min(genreCounts[genre], 10);
    for(let i=0; i<count; i++) {
        const songId = `song-${genre}-${i}`;
        nodes.push({
            id: songId,
            name: `Song in ${genre}`,
            group: 'song',
            radius: 5,
            val: 1,
            connectedEdges: 0
        });
        links.push({
            source: songId,
            target: `genre-${genre}`,
            type: 'song-link',
            weight: 0.5
        });
    }
  });

  // 4. Edges from backend
  if (graphStructure.edges) {
    graphStructure.edges.forEach(edge => {
      links.push({
        source: `genre-${edge.from}`,
        target: `genre-${edge.to}`,
        type: 'genre-link',
        weight: edge.weight
      });
    });
  }

  // Calculate connected edges for each node
  nodes.forEach(node => {
    node.connectedEdges = links.filter(link => 
      link.source.id === node.id || link.target.id === node.id
    ).length;
  });

  document.getElementById('graphNodes').textContent = nodes.length;
  document.getElementById('graphEdges').textContent = links.length;

  updateGraph();
}

function updateGraph() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;

  g.selectAll("*").remove();

  // Links with color coding
  const link = g.selectAll(".link")
    .data(links)
    .enter().append("line")
    .attr("class", "link")
    .attr("stroke", d => {
      if(d.type === 'genre-link') return "rgba(30, 215, 96, 0.4)";
      if(d.type === 'artist-link') return "rgba(138, 43, 226, 0.4)";
      return "rgba(255, 255, 255, 0.15)";
    })
    .attr("stroke-width", d => d.type === 'genre-link' ? 2 : 1)
    .style("stroke-dasharray", d => {
      if (animationsEnabled) {
        return d.type === 'genre-link' ? "5,5" : "0";
      }
      return "0";
    })
    .style("animation", animationsEnabled ? "dash-flow 20s linear infinite" : "none");

  // Nodes
  const node = g.selectAll(".node")
    .data(nodes)
    .enter().append("g")
    .attr("class", "node")
    .call(d3.drag()
        .on("start", dragStarted)
        .on("drag", dragged)
        .on("end", dragEnded));

  // Add pulse rings for animation
  if (animationsEnabled) {
    node.append("circle")
      .attr("class", "pulse-ring")
      .attr("r", d => d.radius * 1.5)
      .attr("fill", "none")
      .attr("stroke", d => {
        if(d.group === 'genre') return '#1ed760';
        if(d.group === 'artist') return '#8a2be2';
        return '#00bcd4';
      })
      .attr("stroke-width", 1)
      .attr("stroke-opacity", 0.3)
      .style("pointer-events", "none");
  }

  node.append("circle")
    .attr("class", "node-circle")
    .attr("r", d => d.radius)
    .attr("fill", d => {
        if(d.group === 'genre') return '#1ed760';
        if(d.group === 'artist') return '#8a2be2';
        return '#00bcd4';
    })
    .attr("stroke", "#fff")
    .attr("stroke-width", d => d.group === 'song' ? 0.5 : 2)
    .style("cursor", "pointer")
    .style("transition", animationsEnabled ? "all 0.3s ease" : "none")
    .on("mouseover", function(event, d) {
      if (animationsEnabled) {
        d3.select(this)
          .classed("glow", true)
          .classed("float", d.group === 'genre');
      }
    })
    .on("mouseout", function(event, d) {
      if (animationsEnabled && selectedNode !== d.id) {
        d3.select(this)
          .classed("glow", false)
          .classed("float", false);
      }
    })
    .on("click", (event, d) => {
        event.stopPropagation(); // Stop background click
        handleNodeClick(d);
    });

  // Labels
  const label = node.append("text")
    .text(d => d.group === 'song' ? '' : d.name)
    .attr("x", d => d.radius + 5)
    .attr("y", 4)
    .attr("font-size", d => d.group === 'genre' ? "14px" : "11px")
    .attr("fill", "white")
    .style("pointer-events", "none")
    .style("text-shadow", "0px 0px 3px black")
    .style("display", showLabels ? "block" : "none");

  // Physics
  simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id)
      .distance(d => {
        if(d.type === 'genre-link') return 350; 
        if(d.type === 'artist-link') return 120;
        return 70;
      })
    )
    .force("charge", d3.forceManyBody().strength(d => {
        if(d.group === 'genre') return -900;
        if(d.group === 'artist') return -300;
        return -50;
    }))
    .force("collide", d3.forceCollide().radius(d => d.radius + 15).strength(0.8))
    .force("center", d3.forceCenter(width / 2, height / 2).strength(0.05))
    .on("tick", ticked);
  
  // Add animated background particles if animations enabled
  if (animationsEnabled) {
    addBackgroundParticles();
  }
  
  setTimeout(() => {
    zoomToFit();
  }, 800);

  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node.attr("transform", d => `translate(${d.x},${d.y})`);
  }
}

function handleNodeClick(d) {
  // Remove previous selection
  resetGraph();
  
  // Set selected node
  selectedNode = d.id;
  
  // 1. Reset Styles first
  d3.selectAll(".node-circle")
    .attr("stroke", "#fff")
    .attr("stroke-width", n => n.group === 'song' ? 0.5 : 2)
    .style("filter", "none");

  // 2. Identify connected nodes and links
  const connectedNodeIds = new Set([d.id]);
  const connectedLinks = [];
  
  // Find all connected links
  links.forEach(link => {
    const sourceId = link.source.id || link.source;
    const targetId = link.target.id || link.target;
    
    if (sourceId === d.id || targetId === d.id) {
      connectedLinks.push(link);
      connectedNodeIds.add(sourceId);
      connectedNodeIds.add(targetId);
    }
  });

  // 3. Highlight connected links with purple and blue colors
  g.selectAll(".link")
    .style("stroke", link => {
      if (connectedLinks.includes(link)) {
        // Purple for artist links, blue for song links
        if (link.type === 'artist-link') return '#8a2be2'; // Purple
        if (link.type === 'song-link') return '#00bcd4';   // Blue
        return '#1ed760'; // Green for genre links
      }
      return "rgba(255, 255, 255, 0.05)";
    })
    .style("stroke-width", link => connectedLinks.includes(link) ? 3 : 1)
    .style("stroke-opacity", link => connectedLinks.includes(link) ? 1 : 0.1);

  // 4. Dim unconnected nodes and highlight connected ones
  g.selectAll(".node")
    .select(".node-circle")
    .style("opacity", nodeData => connectedNodeIds.has(nodeData.id) ? 1 : 0.2)
    .attr("stroke-width", nodeData => {
      if (nodeData.id === d.id) return 4;
      if (connectedNodeIds.has(nodeData.id)) return 2;
      return nodeData.group === 'song' ? 0.5 : 2;
    })
    .attr("stroke", nodeData => {
      if (nodeData.id === d.id) return '#ffff00';
      if (connectedNodeIds.has(nodeData.id)) {
        if (nodeData.group === 'artist') return '#8a2be2';
        if (nodeData.group === 'song') return '#00bcd4';
        return '#1ed760';
      }
      return '#fff';
    });

  // Highlight the clicked node with yellow glow
  g.selectAll(".node")
    .filter(nodeData => nodeData.id === d.id)
    .select(".node-circle")
    .attr("stroke", "#ffff00")
    .attr("stroke-width", 4)
    .style("filter", "drop-shadow(0 0 15px #ffff00)");

  // 5. Show Info Box with more detailed information
  const info = document.getElementById('nodeInfo');
  info.classList.add('active');
  
  const typeLabel = d.group.charAt(0).toUpperCase() + d.group.slice(1);
  const edgeCount = connectedLinks.length;
  
  document.getElementById('infoContent').innerHTML = `
    <div style="margin-bottom:10px; padding: 8px; background: rgba(30, 215, 96, 0.1); border-radius: 6px;">
      <strong style="color:#1ed760;">Type:</strong> <span style="color:#aaa">${typeLabel}</span>
    </div>
    <div style="margin-bottom:10px; padding: 8px; background: rgba(138, 43, 226, 0.1); border-radius: 6px;">
      <strong style="color:#8a2be2;">Name:</strong> <span style="font-size:1.1em; color:white">${d.name}</span>
    </div>
    <div style="margin-bottom:10px; padding: 8px; background: rgba(0, 188, 212, 0.1); border-radius: 6px;">
      <strong style="color:#00bcd4;">Connections:</strong> ${edgeCount} links
    </div>
    <div style="margin-bottom:10px; padding: 8px; background: rgba(255, 255, 255, 0.05); border-radius: 6px;">
      <strong>Strength:</strong> ${d.val} plays
    </div>
    <div style="margin-top: 15px; font-size: 0.9em; color: rgba(255, 255, 255, 0.7);">
      Connected to ${connectedNodeIds.size - 1} other nodes
    </div>
  `;
}

function resetGraph() {
  selectedNode = null;
  const info = document.getElementById('nodeInfo');
  info.classList.remove('active');
  
  // Reset all nodes
  g.selectAll(".node-circle")
    .attr("stroke", "#fff")
    .attr("stroke-width", d => d.group === 'song' ? 0.5 : 2)
    .style("opacity", 1)
    .style("filter", "none")
    .classed("glow", false)
    .classed("float", false);
  
  // Reset all links to default colors
  g.selectAll(".link")
    .style("stroke", d => {
      if(d.type === 'genre-link') return "rgba(30, 215, 96, 0.4)";
      if(d.type === 'artist-link') return "rgba(138, 43, 226, 0.4)";
      return "rgba(255, 255, 255, 0.15)";
    })
    .style("stroke-width", d => d.type === 'genre-link' ? 2 : 1)
    .style("stroke-opacity", 1);
  
  // Reset labels
  g.selectAll("text").style("opacity", 1);
}

function addBackgroundParticles() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;
  
  // Create particle layer
  const particleLayer = svg.append("g").attr("class", "particles");
  
  // Add particles
  for (let i = 0; i < 50; i++) {
    particleLayer.append("circle")
      .attr("r", Math.random() * 2 + 0.5)
      .attr("fill", () => {
        const colors = ['rgba(30, 215, 96, 0.3)', 'rgba(138, 43, 226, 0.3)', 'rgba(0, 188, 212, 0.3)'];
        return colors[Math.floor(Math.random() * colors.length)];
      })
      .attr("cx", Math.random() * width)
      .attr("cy", Math.random() * height)
      .style("animation", `float-particle ${Math.random() * 10 + 10}s ease-in-out infinite`)
      .style("animation-delay", `${Math.random() * 5}s`);
  }
  
  // Add CSS for particle animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes float-particle {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px); }
      50% { transform: translate(${Math.random() * 30 - 15}px, ${Math.random() * 30 - 15}px); }
      75% { transform: translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px); }
    }
    @keyframes dash-flow {
      to { stroke-dashoffset: -1000; }
    }
  `;
  document.head.appendChild(style);
}

function zoomToFit() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;
  
  if (nodes.length === 0) return;
  
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  nodes.forEach(node => {
    if (node.x !== undefined) {
      minX = Math.min(minX, node.x);
      maxX = Math.max(maxX, node.x);
      minY = Math.min(minY, node.y);
      maxY = Math.max(maxY, node.y);
    }
  });
  
  const padding = 80;
  const graphWidth = maxX - minX + 2 * padding;
  const graphHeight = maxY - minY + 2 * padding;
  const scale = Math.min(width / graphWidth, height / graphHeight) * 0.85;
  const translateX = (width - (maxX + minX) * scale) / 2;
  const translateY = (height - (maxY + minY) * scale) / 2;
  
  svg.transition().duration(1000).call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
}

function dragStarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
  svg.style("cursor", "grabbing");
}

function dragged(event, d) {
  d.fx = event.x;
  d.fy = event.y;
}

function dragEnded(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
  svg.style("cursor", "grab");
}

// Add toggle animations button
document.getElementById('animate-btn').addEventListener('click', () => {
  animationsEnabled = !animationsEnabled;
  updateGraph();
});

document.getElementById('zoom-in').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 1.3));
document.getElementById('zoom-out').addEventListener('click', () => svg.transition().call(zoom.scaleBy, 0.7));
document.getElementById('zoom-fit').addEventListener('click', zoomToFit);
document.getElementById('toggle-labels').addEventListener('click', () => {
  showLabels = !showLabels;
  g.selectAll("text").style("display", showLabels ? "block" : "none");
});

window.addEventListener('resize', () => {
  if (svg) {
    const container = document.getElementById('graph-container');
    svg.attr("width", container.clientWidth).attr("height", container.clientHeight);
    setTimeout(zoomToFit, 100);
  }
});

// ---------------------------------
// 2. SONG RECOMMENDATION LOGIC
// ---------------------------------
async function loadRecommendedSongs(orderedGenres) {
  if (!orderedGenres || orderedGenres.length === 0) return;

  const topGenres = orderedGenres.slice(0, 3);
  let songs = [];

  for (const genre of topGenres) {
    try {
      const response = await fetch(`${ITUNES_API}/search?term=${encodeURIComponent(genre)}&media=music&entity=song&limit=15`);
      const data = await response.json();
      
      if (data.results) {
        songs = songs.concat(data.results.map(track => ({
          id: track.trackId,
          title: track.trackName,
          artist: track.artistName,
          cover: track.artworkUrl100.replace('100x100', '300x300'),
          genre: genre,
          preview: track.previewUrl
        })));
      }
    } catch (error) {
      console.error(`Error fetching songs for ${genre}:`, error);
    }
  }

  songs = songs.sort(() => Math.random() - 0.5).slice(0, 12);
  displayRecommendedSongs(songs);
}

function displayRecommendedSongs(songs) {
  const grid = document.getElementById('recommendedSongsGrid');
  grid.innerHTML = '';

  songs.forEach(song => {
    const card = document.createElement('div');
    card.className = 'song-card';
    card.innerHTML = `
      <img class="song-cover" src="${song.cover}" alt="${song.title}" 
           onerror="this.src='https://via.placeholder.com/300x300/1a1a2e/1ed760?text=‚ô™'">
      <div class="song-title">${song.title}</div>
      <div class="song-artist">${song.artist}</div>
      <div class="song-genre">${song.genre}</div>
    `;
    card.addEventListener('click', () => {
      if (song.preview) {
        const audio = new Audio(song.preview);
        audio.play().catch(e => console.log('Autoplay blocked'));
        alert(`‚ñ∂ Playing preview: ${song.title}`);
      } else {
        alert(`No preview available for ${song.title}`);
      }
    });
    grid.appendChild(card);
  });
}

// ---------------------------------
// 3. MAIN DATA LOADING
// ---------------------------------
async function loadRecommendations() {
  const loadingIndicator = document.getElementById('loadingIndicator');
  const dashboardContent = document.getElementById('dashboardContent');
  
  loadingIndicator.style.display = 'block';
  dashboardContent.style.display = 'none';

  try {
    const playlist = JSON.parse(localStorage.getItem('playlist') || '[]');
    const recommendations = JSON.parse(localStorage.getItem('recommendations') || '[]');
    const users = JSON.parse(localStorage.getItem('users') || '[]');

    const response = await fetch(`${API_BASE}/api/recommend`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ playlist, recommendations, users })
    });

    if (!response.ok) throw new Error('Backend error');

    const data = await response.json();
    globalData = data; // SAVE DATA FOR SORTING
    
    loadingIndicator.style.display = 'none';
    dashboardContent.style.display = 'block';

    if (data.success) {
      setTimeout(() => {
        displayDashboard(data);
        initGraph();
        buildGenreGraph(data);
        loadRecommendedSongs(data.orderedGenres);
      }, 50);
    }

  } catch (error) {
    console.error('Error loading recommendations:', error);
    loadingIndicator.innerHTML = `
      <div style="color: #ff4757;">
        ‚ö† Backend connection failed.<br>
        <button class="refresh-btn" onclick="loadRecommendations()">Try Again</button>
      </div>
    `;
  }
}

function displayDashboard(data) {
  const playlist = JSON.parse(localStorage.getItem('playlist') || '[]');
  document.getElementById('totalSongs').textContent = playlist.length;
  document.getElementById('uniqueGenres').textContent = Object.keys(data.genreCounts || {}).length;
  document.getElementById('topGenre').textContent = data.orderedGenres[0] || '-';
  document.getElementById('uniqueArtists').textContent = Object.keys(data.artistCounts || {}).length;

  createChart('genreChart', 'doughnut', data.genreCounts);
  createChart('artistChart', 'bar', data.artistCounts);
  createChart('scoreChart', 'radar', data.recommendationScores);
  createChart('priorityChart', 'line', data.distances || {});
  
  displayGenreList(data.orderedGenres, data.recommendationScores);
}

function createChart(id, type, dataObj) {
    const ctx = document.getElementById(id);
    if(charts[id]) charts[id].destroy();
    
    let labels = Object.keys(dataObj);
    let values = Object.values(dataObj);
    
    if(labels.length > 10) {
        labels = labels.slice(0, 10);
        values = values.slice(0, 10);
    }

    const config = {
        type: type,
        data: {
            labels: labels,
            datasets: [{
                label: 'Data',
                data: values,
                backgroundColor: ['#1ed760', '#8a2be2', '#00bcd4', '#ff4757', '#ffa502'],
                borderColor: '#fff',
                borderWidth: 1,
                fill: type === 'line'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: type === 'doughnut' } },
            scales: (type === 'bar' || type === 'line') ? {
                y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                x: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }
            } : (type === 'radar' ? {
                r: { ticks: { display: false }, grid: { color: 'rgba(255,255,255,0.1)' }, pointLabels: { color: '#fff' } }
            } : {})
        }
    };
    charts[id] = new Chart(ctx, config);
}

function displayGenreList(orderedGenres, scores) {
  const container = document.getElementById('genreListContent');
  container.innerHTML = '';
  orderedGenres.slice(0, 10).forEach((genre, index) => {
    const item = document.createElement('div');
    item.className = 'genre-item';
    item.innerHTML = `
      <div><span style="color: #1ed760; font-weight: bold; margin-right: 0.5rem;">#${index + 1}</span>
      <span class="genre-name">${genre}</span></div>
      <div class="genre-score">Score: ${scores[genre] || 0}</div>
    `;
    container.appendChild(item);
  });
}

// ---------------------------------
// 4. SORTING VISUALIZATION LOGIC (BOXES)
// ---------------------------------
// ---------------------------------
// 4. SORTING VISUALIZATION LOGIC (QUICK SORT)
// ---------------------------------

// ---------------------------------
// 4. SORTING VISUALIZATION LOGIC (QUICK SORT + SPEED CONTROL)
// ---------------------------------

let isSorting = false;
let speedFactor = 1.0; // Multiplier for animation speed

// Listen for slider changes
document.getElementById('speedRange').addEventListener('input', (e) => {
    // Map slider 1-10 to a speed factor
    // 1 = 0.25x speed (Very Slow)
    // 4 = 1.0x speed (Normal)
    // 10 = 4.0x speed (Very Fast)
    const val = parseInt(e.target.value);
    if(val < 4) {
        speedFactor = 0.25 * val; 
    } else {
        speedFactor = 1 + ((val - 4) * 0.5); 
    }
});

document.getElementById('sort-viz-btn').addEventListener('click', () => {
    if(!globalData || !globalData.recommendationScores) {
        alert("Wait for recommendations to load first!");
        return;
    }
    document.getElementById('sortModal').style.display = 'block';
    startSortingVisualization();
});

function closeSortModal() {
    document.getElementById('sortModal').style.display = 'none';
    isSorting = false; 
}

async function startSortingVisualization() {
    isSorting = true;
    const container = document.getElementById('sort-viz-container');
    const statusDiv = document.getElementById('sort-status');
    container.innerHTML = '';

    // 1. Prepare Data
    let scores = globalData.recommendationScores;
    let dataArr = Object.entries(scores).map(([k,v]) => ({name: k, val: v}));
    
    // Shuffle and slice for demo
    dataArr = dataArr.sort(() => Math.random() - 0.5).slice(0, 10);

    // 2. Render Initial Boxes
    dataArr.forEach((item, index) => {
        const box = document.createElement('div');
        box.className = 'sort-box';
        box.id = `box-${index}`;
        
        box.innerHTML = `
            <div class="score-circle">${item.val}</div>
            <div class="label">${item.name}</div>
        `;
        container.appendChild(box);
    });

    statusDiv.innerHTML = "Initializing Quick Sort (Descending)...";
    await sleep(1000);

    // 3. Start Recursive Quick Sort
    await quickSort(container, 0, dataArr.length - 1, statusDiv);

    if (isSorting) {
        statusDiv.innerHTML = "<span style='color:#1ed760'>Sort Complete!</span> Genres ordered by Relevance.";
        Array.from(container.children).forEach(child => child.classList.add('sorted'));
    }
}

// Recursive Quick Sort
async function quickSort(container, low, high, statusDiv) {
    if (!isSorting) return;

    if (low < high) {
        let pi = await partition(container, low, high, statusDiv);
        await quickSort(container, low, pi - 1, statusDiv);
        await quickSort(container, pi + 1, high, statusDiv);
    } else if (low === high) {
        if(container.children[low]) container.children[low].classList.add('sorted');
    }
}

// Partition Function
async function partition(container, low, high, statusDiv) {
    if (!isSorting) return;

    let boxes = container.children;
    
    // Select Pivot (Last element)
    let pivotBox = boxes[high];
    let pivotVal = parseInt(pivotBox.querySelector('.score-circle').innerText);
    let pivotName = pivotBox.querySelector('.label').innerText;

    pivotBox.classList.add('pivot');
    statusDiv.innerHTML = `Pivot selected: <span style="color:#f1c40f">${pivotName}</span>`;
    await sleep(800);

    let i = (low - 1); 

    for (let j = low; j <= high - 1; j++) {
        if (!isSorting) return;

        let currentBox = boxes[j];
        let currentVal = parseInt(currentBox.querySelector('.score-circle').innerText);
        let currentName = currentBox.querySelector('.label').innerText;

        currentBox.classList.add('comparing');
        statusDiv.innerHTML = `Comparing <span style="color:#ff4757">${currentName}</span> vs Pivot`;
        await sleep(600);

        // Sorting DESCENDING (> for Descending, < for Ascending)
        if (currentVal > pivotVal) {
            i++;
            if (i !== j) {
                statusDiv.innerHTML = `Swapping <span style="color:#00bcd4">${currentName}</span> to left`;
                await swapDomNodes(boxes[i], boxes[j]);
                boxes = container.children; // refresh ref
            }
        }
        currentBox.classList.remove('comparing');
    }

    if (i + 1 !== high) {
        statusDiv.innerHTML = `Placing Pivot <span style="color:#f1c40f">${pivotName}</span>`;
        await swapDomNodes(boxes[i + 1], boxes[high]);
    }
    
    boxes = container.children; 
    boxes[i + 1].classList.remove('pivot');
    boxes[i + 1].classList.add('sorted');
    
    return (i + 1);
}

// Helper to swap nodes visually
async function swapDomNodes(nodeA, nodeB) {
    if (nodeA === nodeB) return;

    nodeA.classList.add('swapping');
    nodeB.classList.add('swapping');
    
    // Wait based on speed
    await sleep(600);

    const parent = nodeA.parentNode;
    const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;
    parent.insertBefore(nodeA, nodeB);
    parent.insertBefore(nodeB, siblingA);

    await sleep(200);
    
    nodeA.classList.remove('swapping');
    nodeB.classList.remove('swapping');
}

// DYNAMIC SLEEP FUNCTION
function sleep(ms) {
    // Divides the delay by the speedFactor.
    // If factor is 2 (Fast), delay is halved.
    // If factor is 0.5 (Slow), delay is doubled.
    return new Promise(resolve => setTimeout(resolve, ms / speedFactor));
}

// Initial load
loadRecommendations();
</script>

</body>
</html>